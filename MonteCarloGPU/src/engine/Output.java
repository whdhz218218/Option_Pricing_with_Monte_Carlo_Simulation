package engine;

import java.util.Arrays;

import OpenCL.GBMGenerator;
import OpenCL.NormalGenerator;
import payout.*;
import random.UniformRandomGenerator;

public class Output<ValType>{
	
	private Payout _option;
	private double _avg;                          // mean of the final result
	private double _sigma;                        // sigma of the final result
	private double _y;                            // value computed from probability
	private double _errorlimit;                   // maximum allowed estimation error
	private int _batch;
	private double _r;
	private int _numdays;
	private double _initialP;                     // S0
	private StatsCollector _statscollector;


	public Output(Payout option, double initialP, double r, double sigma, double errorlimit, double p, int batch,int numdays) {
		_option=option;
		_errorlimit=errorlimit;
		double t=Math.sqrt(Math.log(1/(p*p)));
		double c0 = 2.515517;
		double d1 = 1.432788;
		double c1 = 0.802853;
		double d2 = 0.189269;
		double c2 = 0.010328;
		double d3 = 0.001308;
		double y=t-(c0+c1*t+c2*t*t)/(1+d1*t+d2*t*t+d3*Math.pow(t, 3));
		_y=y;
		_batch=batch;
		_r=r;
		_statscollector=new StatsCollector();
		_initialP=initialP;
		_numdays=numdays;
		_sigma=sigma;
	}
	
	
	public double gety() {return _y;}
	public double getmean() {return _avg;}	
	public double getsigma() {return _sigma;}	
	public void setMeanSigma(double mean, double sigma) {
		_avg=mean;
		_sigma=sigma;
	}
	public StatsCollector getStatsCollector() {return _statscollector;}
	
   /** Do one batch of simulation
    * @param uniformRandomGenerator
    * @throws Exception
    */
	public void OneBatch(UniformRandomGenerator uniformRandomGenerator) throws Exception {
		// Create two arrays of uniform random numbers of a batch 
		float[] arr1 = new float[_batch];
		float[] arr2 = new float[_batch];
		
		// Fill in those two arrays with uniform random numbers generated by uniform generator		
		for(int i = 0; i < _batch; i++){
			arr1[i] = (float) uniformRandomGenerator.nextRandom01();
			arr2[i] = (float) uniformRandomGenerator.nextRandom01();
		}

        NormalGenerator normalGenerator = new NormalGenerator(_batch,arr1,arr2);
		// Transform uniform random numbers to normal random numbers
        normalGenerator.UniformtoNormal();
        
		float[] normals1 = new float[_batch];
		float[] normals2 = new float[_batch];
		
		normals1 = normalGenerator.getNormal1();
		normals2 = normalGenerator.getNormal2();
		
		// Use GPU to calculate stock prices which is a geometric brownian motion 
		GBMGenerator GBMGenerator = new GBMGenerator( normals1, normals2,_numdays, (float)_r, (float)_sigma, _batch, (float) _initialP);
		// Compute stock prices at the end of year
		GBMGenerator.NormtoGBM();
		// Store the stock prices got from simulation
		float[] Prices = Arrays.copyOf(GBMGenerator.getpricesOut(), 2*_batch/_numdays);
		// Compute the price of option of each simulation
		for(float price: Prices){		
			//Add  the price of option to statscollector
			_statscollector.update(_option.payout(price));
		}
	}
	
	/** Compute the price of option by conducting two batches of Monte Carlo Simulation
	 */
    public void output() throws Exception{
    	long seed = System.currentTimeMillis();
		long n = Integer.MAX_VALUE;
		UniformRandomGenerator uniformRandomGenerator = new UniformRandomGenerator(seed, n);
		while(true){
			// Do a batch of simulation
			OneBatch(uniformRandomGenerator);
			// Check stopping criteria, stop when we get smaller error than the limit
			if( (_y*_statscollector.getsd()/Math.sqrt(_statscollector.getn()))< _errorlimit )
				break;
		}
		// Print how many times we simulate, must be a multiple of 2M/252
		System.out.println(_statscollector.getn()+" times");
		setMeanSigma(_statscollector.getmean(), _statscollector.getsd());
    }
}
